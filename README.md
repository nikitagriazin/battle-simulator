# Цель

Цель задания — продемонстрировать навыки проектирования ПО. 
Не беспокойтесь о производительности, использовании потоков или подключении библиотек. 
Мы не ожидаем детерминированного результата работы, это усложнило бы задачу.
Время выполнения не ограничено, но ожидается, что оно займет не более 6–8 часов.

## Что мы хотим увидеть:
1. Простой, аккуратный код, по которому легко понять, как он работает.
2. Четкие зоны ответственности каждой сущности в проекте.
3. Архитектуру, позволяющую легко добавлять новые сущности и механики взаимодействия.
    - Представьте, что после вас придут 10 джуниор-разработчиков, которые будут одновременно добавлять новые фичи.

# Задача

Создайте пошаговую симуляцию битвы юнитов на карте для экспериментов с механиками.

Можно создать карту размером W×H клеток и разместить на ней N юнитов.
- Юниты могут быть разного типа с разными действиями и характеристиками.
- Каждый юнит может выполнить одно действие за ход.
    - Юниты действуют в порядке их создания.
- Одну клетку может занимать только один юнит.
- У всех юнитов есть уникальный идентификатор **Id** (целое число) 
- У большинства юнитов есть характеристика **HP** (Health Points).
    - Если **HP** ≤ 0, юнит исчезает на следующий ход и больше не действует.
- Некоторые юниты могут перемещаться:
    - За ход могут переместиться в любую из восьми соседних клеток.
    - Если не могут достичь цели за один ход, продолжают двигаться к ней в следующих ходах.

Симуляция заканчивается, когда нет юнитов, способных действовать в следующем ходу, или на карте остается только один юнит.

## Юниты:

### Мечник
- **Характеристики:** HP, Strength
- **Ближний бой:** Бьет одного случайного юнита в соседней клетке, нанося ему **Strength** единиц урона.
- Если некого бить, перемещается.

### Охотник
- **Характеристики:** HP, Agility, Strength, Range
- **Дальний бой:** Стреляет в случайного юнита на расстоянии от 2 до **Range** клеток, нанося ему **Agility** единиц урона. Может стрелять только если в соседних клетках нет других юнитов.
- **Ближний бой:** Если стрелять не может, бьет одного случайного юнита в соседней клетке, нанося ему **Strength** единиц урона.
- Если некого бить, перемещается.

# Приложение

При запуске приложение получает путь к файлу со сценарием симуляции, где описаны **команды** для создания карты и юнитов, а также перемещения юнитов по карте. 
Приложение должно выводить все происходящие события в **stdout**.

Так как на карте нет препятствий, сложные алгоритмы поиска пути не требуются.

## Команды

- `CREATE_MAP W H` — Создает карту размером `W`×`H`. Эта команда начинает любой сценарий.
- `SPAWN_SWORDSMAN I X Y H S` — Создает мечника с идентификатором `I` в точке `X`,`Y` с характеристиками здоровья `H` и силы `S`.
- `SPAWN_HUNTER I X Y H A S R` — Создает охотника с идентификатором `I` в точке `X`,`Y` с характеристиками здоровья `H`, ловкости `A`, силы `S` и дальности `R`.
- `MARCH I X Y` — Приказывает юниту `I` переместиться в точку `X`,`Y`.

## События

- `MAP_CREATED` — Создание карты.
- `MARCH_STARTED`, `MARCH_ENDED` — Начало и конец перемещения юнита.
- `UNIT_SPAWNED`, `UNIT_DIED` — Создание и смерть юнита.
- `UNIT_MOVED` — Перемещение юнита на клетку.
- `UNIT_ATTACKED` — Атака одного юнита на другого.

Код парсера команд и вывода событий в лог уже содержится в проекте. Если необходимо, его можно менять. Формат ввода и вывода менять нельзя.

Пример сценария находится в файле _commands_example.txt_. Пример лога событий находится в файле _main.cpp_.

# Планы

При разработке учитывайте планы по добавлению новых юнитов, действий и характеристик. 

Эта функциональность не является частью задания, а лишь подсказывает направление при проектировании.

## Башня

- **Характеристики:** HP, Power
- **Дальний бой:** Стреляет в случайного юнита на расстоянии от 2 до 5 клеток, нанося ему **Power** единиц урона.
- Не может перемещаться.

## Лекарь

- **Характеристики:** HP, Spirit
- **Лечение:** Восстанавливает **Spirit** единиц здоровья одному случайному юниту в радиусе 2 клеток.
- Если некого лечить, перемещается.

## Ворон

- **Характеристики:** HP, Agility
- **Летающий юнит:**
    - Не занимает клетку на карте.
    - Может перемещаться на 2 клетки за ход.
    - Не может быть атакован ближнем боем.
    - Может быть атакован в дальнем бою, дистанция до юнита на единицу больше.
- **Ближний бой:** Бьет одного случайного юнита в соседних клетках, нанося ему **Agility** единиц урона.
- Если некого бить, перемещается.

## Мина

- **Характеристики:** Power
- Если в радиусе 2х клеток есть юнит - взрывается в следующем ходу, нанося всем юнитам в радиусе 3х клеток **Power** единиц урона.
- После взрыва исчезает.
- Не может перемещаться.
- Не может быть атакована.
- Не занимает клетку на карте.

# Технические требования

- **ОС:** Ubuntu
- **Компилятор:** clang 15+
- **Стандарт:** C++17 или новее
- **Система сборки:** cmake (в проекте должен быть CMakeLists.txt)
- Задание необходимо опубликовать в любом публичном гит-репозитории (GitHub, Bitbucket и т.д.).

_В процессе выполнения задания вы можете присылать любые вопросы._

---
# Решение
---

## 
### **Общее описание системы**
Данная система моделирует поведение (юнитов), их взаимодействие друг с другом и игровым окружением в формате симуляции. Она основана на объектно-ориентированных принципах и соблюдает модульность через отдельные подсистемы:
- **"Core"** – основное ядро, предоставляющее базовые абстракции, такие как акторы и компоненты.
- **"Units"** – логика юнитов, включая поведение, характеристики, здоровье и атаки.
- **"System"** – управление симуляцией, создание карты, регистрация юнитов и обработка игрового состояния.
- **"Utility"** – вспомогательные классы, такие как математическая библиотека и сервис-локатор.

За основу решения взят паттерн Component. По задумке все игровые объекты обладающие какой-либо логикой наследуются от класса GameObject. Игровые единицы представлены классом Actor, который в свою очередь может быть составлен из всевозможных ActorComponent. Добавление новых компонентов позволяет расширять domain игровой логики отдельным градиентом функционала. В текущем решении представлен минимальный набор компонент необходимых для выполнения базовой задача тестового задания.


Паттерн Component является одним из ключевых архитектурных решений, применяемых в разработке игровых движков и программных систем.

Общие преимущества компонентного паттерна
* Гибкость и расширяемость – система может легко адаптироваться к новым требованиям, добавляя или заменяя отдельные компоненты без изменения основной структуры объекта.
* Разделение ответственности – каждая функциональность инкапсулируется в отдельный компонент, что повышает читаемость кода и упрощает его сопровождение.
* Переиспользуемость кода – компоненты могут использоваться в различных объектах, что снижает дублирование кода и увеличивает эффективность разработки.
* Модульное тестирование – благодаря изолированности компонентов их можно тестировать по отдельности, обеспечивая более надежную проверку системы.

Но главным образом это превращает игровую логику в подобие конструктора. И согласно этой аналогии новых юнитов можно собирать, как из Lego, обогащая новыми компонентами или просто конфигурируя те, что уже имеются в проекте.

Для управления сущностями сервисов и систем был выбран максимально простой ServiceLocator, который позволил гарантировать минимальные возможности IoC.

Основной цикл приложения описан в Simulation, он же управляет структурой игровых объектов, тут они добавляются и удаляются.

## **Основные компоненты системы**
### **1. Core (ядро системы)**
- **Actor/ActorComponent**:
  - Каждый актор использует компонентную архитектуру. У `Actor` есть список компонентов (`ActorComponent`), таких как `HealthComponent`, `AttackComponent` и т. д.
  - **Паттерн "Компонент" (Component):** позволяет гибко добавлять новые функции актору без изменения его структуры или наследования. Это обеспечивает высокую расширяемость кода.

- **OwnedBy и Condition**:
  - `OwnedBy` — компонент для управления принадлежностью объекта, позволяет логически связывать объекты с владельцем, как правило для доступа к другим связанным компонентам.
  - `Condition` используется для создания проверок (например, юнит в зоне атаки). Это похоже на реализацию паттерна **"Спецификация" (Specification)**, так как каждая проверка — это простая спецификация с булевым результатом.

- **GameObject**:
  - Базовый класс, от которого унаследован `Actor`. Это позволяет сохранить общую функциональность для различных игровых объектов.

### **2. Units (логика юнитов и их поведения)**
- **Компоненты юнитов**:
  - Разделение на компоненты, такие как `HealthComponent`, `StatsComponent`, `PositionComponent` и `AttackComponent`, обеспечивает инкапсуляцию и поддержку логики. Например:
    - `HealthComponent` сосредотачивается только на здоровье и его изменениях.
    - `StatsComponent` управляет характеристиками юнитов, такими как сила, ловкость.

- **Паттерн "Стратегия" (Strategy) для атак**:
  - `AttackType` является абстрактным классом, а наследники, такие как `RangeAgilityAttack` и `CloseStrengthAttack`, реализуют конкретные типы атак.
  - Это позволяет выбирать тип атаки в зависимости от ситуации или конфигурации юнита.

- **Паттерн "Состояние" (State) для поведения**:
  - `Behaviour` — абстрактное представление поведения юнита. Конкретные поведения (`MoveAndAttackBehaviour`) расширяют его, определяя конкретные действия.
  - Это позволяет менять поведение юнита в зависимости от контекста (например, использование агрессивной или оборонительной стратегии).

### **3. System (функциональная часть системы)**
- **Map и Simulation**:
  - `Map` организует игровое пространство, элементы которого представлены в виде сетки (`Vector2` для координат).
  - `Simulation` отвечает за обновление текущего игрового состояния и выполнение расчетов в циклической симуляции.
  - **Паттерн "Фасад" (Facade)**: `Simulation` действует как фасад для взаимодействия с подсистемами, такими как `GameState`, `Map`, и компоненты юнитов, упрощая управление основной логикой.

- **Mediator для управления командами**:
  - `GameCommandMediator` работает как главный посредник для обработки команд в системе.
  - **Паттерн "Медиатор" (Mediator):** минимизирует количество прямых связей между обработчиками команд (`CommandHandler`), фабриками, картой и юнитами, облегчая взаимодействие между компонентами. Например:
    - `CreateMapHandler` обрабатывает команды создания карты.
    - `SpawnSwordsmanHandler` и `SpawnHunterHandler` запускают обработку логики спауна юнитов.

- **Command Queue**:
  - Очередь команд (`GameCommandQueue`) реализует хранение и обработку команд. Это упрощает управление порядком выполнения.

### **4. Utility (вспомогательные элементы)**
- **Vector2**:
  - Базовый класс для представления координат. Обеспечивает операции с векторами и используется в классе `Map` для отслеживания расположения объектов.

- **ServiceLocator**:
  - Используется для поиска зависимости. 

## **Примененные паттерны**
### 1. **Компонент (Component)**
- Используется в архитектуре акторов (например, `Actor`, `ActorComponent`) для гибкого подключения функционала.
- Позволяет масштабировать сущности без изменения их основного кода.

### 2. **Стратегия (Strategy)**
- `AttackType` позволяет динамически выбирать тип атаки юнита (например, ближняя атка или дальняя).

### 3. **Медиатор (Mediator)**
- `GameCommandMediator` устраняет взаимозависимости между обработчиками команд, централизуя управление их реализацией.

### 4. **Спецификация (Specification)**
- `Condition` представляет собой шаблон проверки условий (например, "юнит в зоне действия"), что позволяет создавать легко расширяемые условия.

### 5. **Фабрика (Factory)**
- `UnitFactory` создаёт юниты, абстрагируя процесс их инициализации от основного кода.

### 6. **Фасад (Facade)**
- `Simulation` упрощает доступ к подсистемам, объединяя управление игровым процессом в один интерфейс.

### 7. **Состояние (State)**
- `Behaviour` и его наследники (`MoveAndAttackBehaviour`) представляют собой систему изменения поведения юнитов в зависимости от контекста.

## **Преимущества архитектуры**
1. **Модульность и расширяемость**:
  - Использование компонентной системы в классе `Actor` позволяет добавлять новые функции без модификации существующего кода.
  - Паттерн `Mediator` и очередь команд обеспечивают управление взаимодействиями между компонентами, упрощая добавление новых типов команд.

2. **Тестируемость**:
  - Все компоненты (`ActorComponent`, `UnitFactory`, `CommandHandler`) абстрагированы и легко тестируются изолированно.

3. **Повторное использование**:
  - Компоненты (`HealthComponent`, `BehaviourLogicComponent`) можно переиспользовать в других проектах.

4. **Устойчивость к изменениям**:
  - Легко менять поведение юнитов (`Strategy`, `State`) или работу системы в целом.

PS: Не сдержался и прикрутил A* для построения пути. 